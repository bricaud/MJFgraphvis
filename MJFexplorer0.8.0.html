<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<title>MJF EXPLORER</title>
<head>
<link rel="stylesheet" href="MJFstyle0.7.3.css">
<link rel="stylesheet" href="assets/css/styles.css">
<!--<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
<script src="http://code.jquery.com/jquery-1.11.1.min.js"></script>-->
<link rel="stylesheet" href="font-awesome.min.css">
<!--<script src="jquery-1.11.3.min.js"></script>-->
<script src="jquery-3.1.0.min.js"></script>
<!-- <link rel="stylesheet" href="68eddd94.main.css">-->

<!--<script src="http://d3js.org/d3.v3.min.js"></script>-->
<script src="d3.min.js"></script>
<script src="MJFexplorer.conf.js"></script>
<script src="graphlayout0.7.3.js"></script>
<script src="infobox.js"></script>
<script src="graph_viz.js"></script>
<script type="text/javascript">
<!--javascript code goes here-->





//////////////////////////////////////
function refresh_data(d,center_f,with_active_node){

  var nb_layers = 4;

  var svg_graph = graph_viz.svg_handle();

  //new_Nodes = d.nodes.slice(old_Nodes.length);
  //new_Links = d.links.slice(old_Links.length);
  // Save the data
  previous_nodes =  svg_graph.selectAll("g").filter(".node");
  previous_nodes_data = previous_nodes.data();
  old_Nodes = updateAdd(old_Nodes,previous_nodes_data);
  previous_links =  svg_graph.selectAll(".links");
  //console.log(previous_links);
  previous_links_data = previous_links.data();
  old_Links = updateAdd(old_Links,previous_links_data);

  // handle the pinned nodes
  pinned_Nodes = svg_graph.selectAll("g").filter(".pinned");
  pinned_nodes_data = pinned_Nodes.data();
  //old_Nodes = updateAdd(old_Nodes,pinned_nodes_data);

  // get the node data and merge it with the pinned nodes
  Nodes = d.nodes;
  //console.log('Nb of pinned nodes: '+ pinned_nodes_data.length)
  Nodes = updateAdd2(Nodes,pinned_nodes_data);
  //console.log(Nodes);
  // add coordinates to the new active nodes that already existed in the previous step
  Nodes = transfer_coordinates(Nodes,old_Nodes);

  // retrieve the links between nodes and pinned nodes
  Links = d.links.concat(previous_links_data); // first gather the links
  //console.log(previous_links_data)
  Links = find_active_links(Links,Nodes); // then find the ones that are between active nodes
  //console.log(Links)

  //Links = d.links;
  //Links = Links.concat(pinned_links_data);

  



  //////////////////////////////////////
  // link handling

  // old links become older
  for (var k=nb_layers;k>0;k--) {
    kp=k-1;
    svg_graph.selectAll(".old_links"+kp).attr("class","old_links"+k);
  };
 
  //attach the data
  var data_link = svg_graph.selectAll(".links")
    .data(Links, function(d) { return d.id; });
  
  // links not active anymore are classified old_links
  data_link.exit().attr("class","old_links0");

  // handling active links associated to the data
  //var link = data_link.enter().merge(data_link).append("g").attr("class", "links").append("line");
  var link = data_link.enter().append("line").attr("class", "links")
      .attr("source_ID",function(d) { return d.source;})
      .attr("target_ID",function(d) { return d.target;});
 
  // previous links plus new links are merged
  link = link.merge(data_link);


  ///////////////////////////////////
  // node handling

  for (var k=nb_layers;k>0;k--) {
    kp=k-1;
    svg_graph.selectAll(".old_node"+kp).attr("class","old_node"+k);
  };

 //console.log(Nodes);

  var data_node = svg_graph.selectAll("g").filter(".node")
          .data(Nodes, function(d) { return d.id; });

  //console.log(data_node);
  // old nodes not active any more are tagged
  data_node.exit().attr("class","old_node0");
  data_node.exit().selectAll(".Active").remove();// ???

  // nodes associated to the data are constructed
  var node = data_node
          //.enter().merge(data_node).append("g")
          .enter().append("g")
          .attr("class", "node").attr("ID",function(d) { return d.id;})
          .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

  // add node decoration
  decorate_node(node,with_active_node);


  node_pin = d3.selectAll(".Pin");
  node_pin.on("click",pin_it);

  node.on("click", clicked)
      .on("mouseover", function(){
        d3.select(this).select(".Pin").style("visibility", "visible");
        d3.select(this).selectAll(".text_details").style("visibility", "visible");
      })
      .on("mouseout", function(){
        chosen_node = d3.select(this);
        if(!chosen_node.classed("pinned"))
          d3.select(this).select(".Pin").style("visibility", "hidden");
          var show_checked = document.getElementById ("showName").checked;
          if (!show_checked)
            d3.select(this).selectAll(".text_details").style("visibility", "hidden");
      });

  svg_graph.selectAll("g").filter(".pinned").moveToFront();

  // remove all the duplicates node and links among the old_nodes and old_links
  d3.selectAll(".node").each(function(d){
    var ID=d.id;
    for(n=0;n<nb_layers;n++){
      list_old_nodes = d3.selectAll(".old_node"+n);
      //list_old_nodes_data = list_old_nodes.data();
      list_old_nodes.each(function(d){
        if(d.id==ID){
          d3.select(this).remove();
          //console.log('Removed!!')
        }
      })
    }
  });

  d3.selectAll(".links").each(function(d){
    var ID=d.id;
    for(n=0;n<nb_layers;n++){
      list_old_links = d3.selectAll(".old_links"+n);
      //list_old_nodes_data = list_old_nodes.data();
      list_old_links.each(function(d){
        if(d.id==ID){
          d3.select(this).remove();
          //console.log('Removed!!')
        }
      })
    }
  });


  //////////////////////////////////
  // Handling mouse events

  function dragstarted(d) {
    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
    /*
    svg.selectAll(".old_node").each(function(d){
      if (d3.select(this).attr("ID")== +d.id) {d3.select(this).remove(); console.log('removed!')};
    });
    svg.selectAll(".old_links").each(function(d){
      if (d3.select(this).attr("target_ID")== +d.id) {d3.select(this).remove(); console.log('removed!')};
    });
    svg.selectAll(".old_links").each(function(d){
      if (d3.select(this).attr("source_ID")== +d.id) {d3.select(this).remove(); console.log('removed!')};
    });*/
  }

  function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
  }

  function dragended(d) {
    if (!d3.event.active) simulation.alphaTarget(0);
    // d.fx = null;
    // d.fy = null;
  }

  function clicked(d) {
    d3.select(".Active").remove();
    //d3.select(this)
    //  .append("circle").classed("Active",true)
    //  .attr("r", 4)
    //  .attr("transform", function(d) { return "translate(-12,-12)"; })
    //  .attr("fill", function(d) { return color(d.labelV); });
    var input = document.getElementById ("freeze-in");
    var isChecked = input.checked;
    if (isChecked) infobox.display_info(d);
    else {
      simulation.stop();
      svg_graph.selectAll(".old_node"+nb_layers).remove();
      svg_graph.selectAll(".old_links"+nb_layers).remove();
      infobox.display_info(d);
      click_query(d);              
    //d3.select(this).attr("class","active_node");
    }
  }

  function pin_it(d){
    d3.event.stopPropagation();
    node_pin = d3.select(this);
    pinned_node = d3.select(this.parentNode);
    //console.log(pinned_node.classed("node"));
    if (pinned_node.classed("node")){
      if (!pinned_node.classed("pinned")){
        pinned_node.classed("pinned",true);
        console.log('Pinned!');
        node_pin.attr("fill", "#000");
        pinned_node.moveToFront();
      }
      else {
        pinned_node.classed("pinned",false);
        console.log('Unpinned!');
        node_pin.attr("fill", function(d) { return color(d.labelV); });
      }
    }
  }

  nodeSvg = node.merge(data_node);

  ///////////////////////////////
  // Force simulation
  // simulation model and parameters
  
  

  simulation = graph_viz.simulation_start(center_f);
  // Associate the simulation with the data
  simulation.nodes(Nodes).on("tick", ticked);
  simulation.force("link").links(Links);
  simulation.alphaTarget(0);

  ////////////////////////
  // handling simulation steps
  // move the nodes and links at each simulation step, following this rule:
  function ticked() {
    link
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });
    nodeSvg
      .attr("transform", function(d) { return "translate(" + d.x + ", " + d.y + ")"; });  
  }
  
}

///////////////////////////////////////////////
function search_query(){
  if (typeof simulation!=='undefined') {simulation.stop(); console.log('Simulation stopped!');}
   post_cypherquery();
}



</script>
<!-- ------------------------------------------------- -->



	</head>
	<body>
		<div class="header">
			<div class="container">
				<h1 class="header-heading">MJF EXPLORER 0.8.0</h1>
			</div>
		</div>
		<div class="nav-bar">
			<div class="container">
				<ul class="nav">
					<li>Enter a name: <input name="cypher" id="cypher-in" value="King" /></li>
					<li><label for="type">Select neighbors type:</label>
    					<select id="n_type" name="type">
    					<option value="1"> Concerts </option>
      					<option value="2"> Bands </option>
      					<option value="3" selected> Concerts and Bands </option>
      					</select>
      				</li>
					<li><button name="post cypher" onclick="search_query();">Search</button></li>
					<li><button name="show" onclick="refresh_data(graph,center_f=1);">Show</button></li>
					<li><button name="clear" onclick="graph_viz.clear();">Clear</button></li>
          <li><input type="checkbox" name="Freeze" id="freeze-in" />Freeze exploration</li>
          <li><input type="checkbox" name="showName_box" id="showName" onclick="utils.show_names()"/>Show names</li>
				</ul>
			</div>
		</div>
		<div class="content">
			<div class="container">
				<div class="main" id="main">
					<!--<svg width="800" height="800"></svg>-->
					<svg width="900" height="900"></svg>

				</div>
				<div class="aside" id="details" style="background-color:transparent;">
					<div id="messageArea"></div><div id="outputArea"></div>
       				<center><svg width="200" height="200"></svg></center>
				</div>
			</div>
		</div>
		<div class="content">
			<div class="container">
				<div  class="main" id="Wiki_details" style="background-color:transparent;">	
				</div>
			</div class="container">
		</div>
		<div class="footer">
			<div class="container">
				<a href="#">About</a>
			</div>
		</div>
<script type="text/javascript">
var width = 960,
  height = 500;

// Create the graph canvas in the chosen div element
graph_viz.init("#main",width,height);
// Add the zoom layer to the graph
//var svg_graph = 
graph_viz.addzoom();

// Create the info box for node details
infobox.create("#details","#Wiki_details"); // from module in infobox.js



var Data = [];
var graph = [];
var Nodes = [];
var Links = [];
var old_Nodes = [];
var old_Links = [];


</script>

	</body>
</html>